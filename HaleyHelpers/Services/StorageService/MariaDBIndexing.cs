using Haley.Abstractions;
using Haley.Enums;
using Haley.Models;
using Haley.Utils;
using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Runtime.CompilerServices;
using System.Security.Claims;
using System.Security.Cryptography;
using System.Text;
using System.Threading.Tasks;
using System.Xml.Linq;
using static Haley.Internal.IndexingConstant;
using static Haley.Internal.IndexingQueries;

namespace Haley.Utils {
    public class MariaDBIndexing : IDSSIndexing {
        const string DB_CORE_SQL_FILE = "dsscore.sql";
        const string DB_CLIENT_SQL_FILE = "dssclient.sql";
        const string DB_CORE_FALLBACK_NAME = "mss_core";
        const string DB_CORE_SEARCH_TERM = "dss_core";
        const string DB_CLIENT_SEARCH_TERM = "dss_client";
        const string DB_SQL_FILE_LOCATION = "Resources";
        const string DB_CLIENT_NAME_PREFIX = "dss_";
        string _key;
        IAdapterGateway _agw;
        bool isValidated = false;
        async Task EnsureValidation() {
            if (!isValidated) await Validate();
        }

        ConcurrentDictionary<string, OSSModuleInfo> _idxModules = new ConcurrentDictionary<string, OSSModuleInfo>();
        ConcurrentDictionary<string, OSSClientInfo> _idxClients = new ConcurrentDictionary<string, OSSClientInfo>();
       
        public async Task<IFeedback> RegisterClient(OSSClientInfo info) {
            if (info == null) throw new ArgumentNullException("Input client directory info cannot be null");
            info.Assert();
            //We generate the hash_guid ourselves for the client.
            await EnsureValidation();

            //Do we even need to check if the client exists? Why dont' we directly upsert the values??? We need to check, because, if we try upsert, then each time , we end up with a new autogenerated id that is not consumed. So, we might end up with all ids' consumed in years. For safer side, we use upsert, also, we check if id exists and try to update separately.

            var result = await _agw.Scalar(new AdapterArgs(_key) { Query = CLIENT.EXISTS }, (NAME, info.Name));
            var thandler = _agw.GetTransactionHandler(_key); //For both cases, update or upsert, we use inside a transaction.
            if (result != null && result is int cliId) {
                //Client exists. We just need to update.
                using (thandler.Begin()) {
                    //Register client
                    await _agw.NonQuery((new AdapterArgs(_key) { Query = CLIENT.UPDATE }).ForTransaction(thandler), (DNAME, info.DisplayName), (PATH, info.Path),(ID, cliId));
                    await _agw.NonQuery((new AdapterArgs(_key) { Query = CLIENT.UPSERTKEYS }).ForTransaction(thandler), (ID, cliId), (SIGNKEY, info.SigningKey), (ENCRYPTKEY, info.EncryptKey), (PASSWORD, info.PasswordHash));
                }
            } else {
                
                if (info.HashGuid == null) {
                    info.DisplayName.TryPopulateControlledGUID(out var hashGuid, OSSParseMode.ParseOrGenerate, false); //Not error thrown.
                    info.HashGuid = hashGuid.ToString("N"); //No Context added. Check this one later.
                }
                using (thandler.Begin()) {
                    //Register client
                    await _agw.NonQuery((new AdapterArgs(_key) { Query = CLIENT.UPSERT }).ForTransaction(thandler), (NAME, info.Name), (DNAME, info.DisplayName), (GUID, info.HashGuid), (PATH, info.Path));
                    result = await _agw.Scalar((new AdapterArgs(_key) { Query = CLIENT.EXISTS }).ForTransaction(thandler), (NAME, info.Name));
                    if (result != null && result is int clientId) {
                        //await _agw.Read(new AdapterArgs(_key) { Query = $@"select * from client as c where c.id = {clientId};" });
                        //Add Info
                        await _agw.NonQuery((new AdapterArgs(_key) { Query = CLIENT.UPSERTKEYS }).ForTransaction(thandler), (ID, clientId), (SIGNKEY, info.SigningKey), (ENCRYPTKEY, info.EncryptKey), (PASSWORD, info.PasswordHash));
                    }
                }
            }

            if (result != null && result is int resultId) {
                //Every time a client is sucessfully done. We validate if it is present or not.
                await ValidateClient(info);
                return new Feedback(true) { Result = resultId };
            }
            return new Feedback(false, "Unable to index the client");
        }
        public async Task<IFeedback> RegisterModule(OSSModuleInfo info) {
            if (info == null) throw new ArgumentNullException("Input Module directory info cannot be null");
            info.Assert();
            //We generate the hash_guid ourselves for the client.
            await EnsureValidation();

            //Check if client exists. If not throw exeception or don't register? //Send feedback.
            var cexists = await _agw.Scalar(new AdapterArgs(_key) { Query = CLIENT.EXISTS }, (NAME, info.ClientName.ToDBName()));
            if (cexists == null || !(cexists is int clientId)) throw new ArgumentException($@"Client {info.ClientName} doesn't exist. Unable to index the module {info.DisplayName}.");
            var mexists = await _agw.Scalar(new AdapterArgs(_key) { Query = MODULE.EXISTS }, (NAME, info.Name), (PARENT, clientId));
            if (mexists != null && mexists is long mId) {
                //Module exists. .just update it.
                await _agw.NonQuery(new AdapterArgs(_key) { Query = MODULE.UPDATE }, (DNAME, info.DisplayName), (PATH, info.Path),(CONTROLMODE,(int)info.ControlMode),(PARSEMODE,(int)info.ParseMode), (ID, mId));
            } else {
                if (info.HashGuid == null) {
                    info.DisplayName.TryPopulateControlledGUID(out var hashGuid, OSSParseMode.ParseOrGenerate, false); //Not error thrown.
                    info.HashGuid = hashGuid.ToString("N"); //No Context added. Check this one later.
                }

                await _agw.NonQuery(new AdapterArgs(_key) { Query = MODULE.UPSERT }, (PARENT, clientId), (NAME, info.Name), (DNAME, info.DisplayName), (GUID, info.HashGuid), (PATH, info.Path),(CONTROLMODE, (int)info.ControlMode), (PARSEMODE, (int)info.ParseMode));
            }

            mexists = await _agw.Scalar(new AdapterArgs(_key) { Query = MODULE.EXISTS }, (NAME, info.Name), (PARENT, clientId));

            if (mexists != null && mexists is long moduleId && TryCreateModuleKey(info.Name,info.ClientName,out var mKey)) {
                //Now add this information to the indexed modules
                if (!_idxModules.ContainsKey(mKey)) {
                    //Either not present.. or present but empty.
                    _idxModules.TryAdd(mKey, info);
                } else if (_idxModules[mKey] == null) {
                    _idxModules.TryUpdate(mKey, info, null);
                }
                return new Feedback(true, "Module Indexed.") { Result = moduleId };
            }

            return new Feedback(false, "Unable to index the module");
        }
        public async Task Validate() {
            try {
                //If the service or the db doesn't exist, we throw exception or else the system would assume that nothing is wrong. If they wish , they can still turn of the indexing.
                if (!_agw.ContainsKey(_key)) throw new ArgumentException($@"Storage Indexing service validation failure.No adapter found for the given key {_key}");
                //Next step is to find out if the database exists or not? Should we even try to check if the database exists or directly run the sql script and create the database if it doesn't exists?
                var sqlFile = Path.Combine(AssemblyUtils.GetBaseDirectory(), DB_SQL_FILE_LOCATION, DB_CORE_SQL_FILE);
                if (!File.Exists(sqlFile)) throw new ArgumentException($@"Master sql file for creating the storage DB is not found. Please check : {DB_CORE_SQL_FILE}");
                //if the file exists, then run this file against the adapter gateway but ignore the db name.
                var content = File.ReadAllText(sqlFile);
                //We know that the file itself contains "dss_core" as the schema name. Replace that with new one.
                var dbname = _agw[_key].Info?.DBName ?? DB_CORE_FALLBACK_NAME; //This is supposedly our db name.
                content = content.Replace(DB_CORE_SEARCH_TERM, dbname);
                //?? Should we run everything in one go or run as separate statements???
                await _agw.NonQuery(new AdapterArgs(_key) { ExcludeDBInConString = true, Query = content });
                isValidated = true;
            } catch (Exception ex) {
                throw ex;
            }
           
        }
        async Task ValidateClient(OSSClientInfo info) {
            if (_idxClients.ContainsKey(info.Name) && _idxClients[info.Name] != null) return; //WHAT IF KEY IS PRESENT BUT IN ACTUAL THE DATABASE WAS DELETED MANUALLY? SHOULDN'T WE CHECK THAT? OR DIRECTLY THROW EXCEPTION AT RUN TIME? OR THAT THE DETAILS ARE NOT UPDATED?
            //if not, we need to ensure that this client schema is created and then add it internally.
            if (string.IsNullOrWhiteSpace(info.HashGuid)) info.HashGuid = info.DisplayName.CreateGUID(HashMethod.Sha256).ToString();
            if (string.IsNullOrWhiteSpace(info.DatabaseName)) info.DatabaseName = $@"{DB_CLIENT_NAME_PREFIX}{info.HashGuid.ToString().Replace("-", "")}";
            var sqlFile = Path.Combine(AssemblyUtils.GetBaseDirectory(), DB_SQL_FILE_LOCATION, DB_CLIENT_SQL_FILE);
            if (!File.Exists(sqlFile)) throw new ArgumentException($@"Master sql for client file is not found. Please check : {DB_CLIENT_SQL_FILE}");
            //if the file exists, then run this file against the adapter gateway but ignore the db name.
            var content = File.ReadAllText(sqlFile);
            //We know that the file itself contains "dss_core" as the schema name. Replace that with new one.
            content = content.Replace(DB_CLIENT_SEARCH_TERM, info.DatabaseName);
            //?? Should we run everything in one go or run as separate statements???
            await _agw.NonQuery(new AdapterArgs(_key) { ExcludeDBInConString = true, Query = content });
            if (_idxClients.ContainsKey(info.Name)) {
                _idxClients.TryUpdate(info.Name, info, null); //Gives the schema name
            } else {
                _idxClients.TryAdd(info.Name, info);
            }
        }
        async Task ValidateClient(string name) {
            name.AssertValue(true, "Client Name");
            var clientName = name.ToDBName();
            
            await ValidateClient(new OSSClientInfo() { SaveAsName = clientName,DisplayName = name});
        }

        public OSSClientInfo GetClientInfo(string name) {
            if(!name.AssertValue(false))return null;
            var dbname = name.ToDBName();
            if (_idxClients.ContainsKey(dbname)) return _idxClients[dbname];
            return null;
        }

        public OSSModuleInfo GetModuleInfo(string name, string client_name) {
            if (!TryCreateModuleKey(name, client_name, out var moduleKey)) return null;
            if (_idxModules.ContainsKey(moduleKey)) return _idxModules[moduleKey];
            return null;
        }

        public bool TryCreateModuleKey(string name,string client_name,out string modKey) {
            modKey = string.Empty;
            if (!name.AssertValue(false)) return false;
            if (!client_name.AssertValue(false)) return false;
            modKey = $@"{client_name.ToDBName()}##{name.ToDBName()}";
            return true;
        }

        public bool TryAddInfo(OSSDirectory dirInfo) {
            if (dirInfo == null || !dirInfo.Name.AssertValue(false)) return false;
            if (dirInfo is OSSClientInfo clientInfo) {
                if (_idxClients.ContainsKey(clientInfo.Name)) return false;
                _idxClients.TryAdd(dirInfo.Name, clientInfo);
            } else if (dirInfo is OSSModuleInfo modInfo) {
                if (!TryCreateModuleKey(modInfo.Name, modInfo.ClientName, out var mKey)) return false;
                if (_idxModules.ContainsKey(mKey)) return false; 
                _idxModules.TryAdd(mKey, modInfo);
            }
            return true;
        }

        public MariaDBIndexing(IAdapterGateway agw, string key) {
            _key = key;
            _agw = agw;
        }
    }
}
